---
title: "Rapid Spring Boot: Notes on JWT Authentication and JPA Data Persistence"
date: 2024/02/28
description: My developer notes on quickly getting to grips with JWT authentication and data persistence in Spring Boot 3. I cover my experiences with Spring Security, the power of JPA annotations for entity management, stateless sessions with JWT, and BCrypt password encryption, contrasting it with older Java EE approaches.
tag: spring-boot, spring-security, spring-data-jpa, jwt, bcrypt, java-persistence-api, jpa, authentication, authorization, api-security, java
author: Aug
---


**Abstract:**  
This post shares developer notes on rapidly implementing JWT authentication and data persistence in Spring Boot 3. It covers experiences with Spring Security, the efficiency of JPA annotations for entity management, creating stateless sessions with JWTs, and using BCrypt for password encryption. The author contrasts these modern Spring Boot approaches with older Java EE practices, highlighting the power of annotations and abstractions.

**Estimated reading time:** _3 minutes_

As I've been quickly ramping up on modern Spring Boot for implementing security and data persistence (with a lot of help from AI coding assistants!), I wanted to capture some key concepts and observations. These are largely notes for my own reference to keep track of how I've approached things, especially contrasting with older Java development practices, but perhaps they'll be useful to others on a similar journey.

**The Old World vs. Modern Spring: Annotations and Abstractions**

At a previous job, I worked on a large enterprise Java application that was over 15 years old. It originated before Spring became widespread and, as such, didn't use annotations much (except for some newer frontend-related code). That system was deployable to various application servers like JBoss, WebSphere, or WebLogic, and it had its own custom database abstraction layer, security mechanisms, and authorization logic. It was a world of extensive boilerplate and manual configuration.

Fast forward to modern Spring (I'm using Spring Core 6, specifically `spring-boot-starter-data-jpa` version 3.0.4 for persistence, and `org.springframework.boot:spring-boot-starter-security` version 3.0.4 for security), and so much of that heavy lifting is handled for you. You write significantly less code. However, for someone new to Spring, the sheer power packed into its annotations can be a bit bewildering because so much functionality happens "behind the scenes."

**JPA for Effortless Data Persistence**

With Spring Data JPA (Java Persistence API), I quickly learned how a few simple annotations can replace mountains of old JDBC (Java Database Connectivity) code:

- **`@Entity`**: Marks a Java class as a representation of a database table.
- **`@Id`**: Designates a field as the primary key for that entity.
- **`@GeneratedValue`**: Configures the primary key to be auto-incrementing.
- **`@CollectionTable` and `@JoinColumn`**: Used for defining one-to-many relationships with child tables.

By using these annotations, I found I didn't need to write _any_ raw JDBC code, manage database connections manually, or construct SQL queries for basic CRUD (Create, Read, Update, Delete) operations. Spring Data JPA even handled the DDL (Data Definition Language) to create the underlying database tables based on my entities.

**Securing Applications with Spring Security**

On the security front, Spring Security provides a robust framework:

- **`SecurityFilterChain`**: This is a core component where you define your security rules. I learned to use it to restrict access to URL patterns based on user roles and to enable stateless session management, which is ideal for modern APIs.
- **JWT (JSON Web Tokens) for Stateless Authorization**: I implemented JWTs for handling authorization without needing to maintain server-side session state. This involves:
  - Loading a JWT secret from application properties.
  - Using this secret to generate a signing key (e.g., with HMAC-SHA algorithms) for creating and validating tokens.
- **Password Encryption**: User passwords stored in the database are, of course, encrypted. I used `BCryptPasswordEncoder` for this, which is a strong, widely recommended hashing algorithm.

**The Authentication Flow**

The typical authentication process I set up looks like this:

1.  A **`UserRepository`** (an interface extending Spring Data's `JpaRepository`) is used to load user credentials from the `User` table in the database.
2.  Spring's **`AuthenticationManager`** takes the username and password from an incoming login request and compares the provided password (after hashing) against the hashed password stored in the database.
3.  If authentication is successful, a JWT is generated and returned to the client. This token usually includes essential user information like username, email, and some profile details (name, title, etc.).
4.  For subsequent requests to protected API endpoints, the client must include this JWT in the request header (typically as a Bearer token) for the session to be authorized.

As a side note, when I tried to explore the inner workings by navigating to Spring's `AuthenticationManager` implementation code in VSCode (using Ctrl+Click on the `authenticate` method), it didn't quite take me where I expected. It's a reminder of how much abstraction Spring provides â€“ powerful, but sometimes you have to dig a bit deeper to see all the gears turning!

Overall, my dive into modern Spring Boot for security and persistence has been a productive one. The framework handles so much complexity, allowing developers to focus more on business logic.
